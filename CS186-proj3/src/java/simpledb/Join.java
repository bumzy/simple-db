package simpledb;

import java.util.*;
import simpledb.Aggregator.Op;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends Operator {

    private static final long serialVersionUID = 1L;
    public static int BLOCK_SIZE = 1024 * 1024;

    private JoinPredicate p = null;
    private DbIterator[] children = null;
    private TupleDesc td = null;
    private ArrayList<Tuple> preLeftBlock = null;
    private TupleIterator joinResult = null;
    /**
     * Constructor. Accepts to children to join and the predicate to join them
     * on
     *
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
        this.p = p;
        this.children = new DbIterator[]{child1, child2};
        TupleDesc td1 = child1.getTupleDesc();
        TupleDesc td2 = child2.getTupleDesc();
        this.td = TupleDesc.merge(td1, td2);
        this.preLeftBlock = null;
        this.joinResult = null;
    }

    public JoinPredicate getJoinPredicate() {
        return p;
    }

    /**
     * @return
     *       the field name of join field1. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField1Name() {
        TupleDesc td1 = children[0].getTupleDesc();
        int field1 = p.getField1();
        return td1.getFieldName(field1);
    }

    /**
     * @return
     *       the field name of join field2. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField2Name() {
        TupleDesc td2 = children[1].getTupleDesc();
        int field2 = p.getField2();
        return td2.getFieldName(field2);
    }

    /**
     * @see simpledb.TupleDesc#merge(TupleDesc, TupleDesc) for possible
     *      implementation logic.
     */
    public TupleDesc getTupleDesc() {
        return this.td;
    }

    public void open() throws DbException, NoSuchElementException,
            TransactionAbortedException {
        children[0].open();
        children[1].open();
        this.preLeftBlock = null;
        this.joinResult = null;
        super.open();
    }

    public void close() {
        super.close();
        children[1].close();
        children[0].close();
        this.preLeftBlock = null;
        this.joinResult = null;
    }

    public void rewind() throws DbException, TransactionAbortedException {
        children[1].rewind();
        children[0].rewind();
        this.preLeftBlock = null;
        this.joinResult = null;
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no
     * more tuples. Logically, this is the next tuple in r1 cross r2 that
     * satisfies the join predicate. There are many possible implementations;
     * the simplest is a nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of Join
     * are simply the concatenation of joining tuples from the left and right
     * relation. Therefore, if an equality predicate is used there will be two
     * copies of the join attribute in the results. (Removing such duplicate
     * columns can be done with an additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple fetchNext() throws TransactionAbortedException, DbException {
        DbIterator child1 = children[0];
        DbIterator child2 = children[1];
        int size1 = BLOCK_SIZE / child1.getTupleDesc().getSize();
        int size2 = BLOCK_SIZE / child2.getTupleDesc().getSize();
        while (joinResult != null && joinResult.hasNext()) {
            return joinResult.next();
        }
        while (preLeftBlock != null || child1.hasNext()) {
            ArrayList<Tuple> leftBlock = null;
            if (preLeftBlock != null) {
                leftBlock = preLeftBlock;
                preLeftBlock = null;
            } else {
                leftBlock = getNextSortedBlock(child1, size1, this.p.getField1());
                child2.rewind();
            }
            while (child2.hasNext()) {
                ArrayList<Tuple> rightBlock = getNextSortedBlock(child2, size2, this.p.getField2());
                joinResult = mergeJoin(leftBlock, rightBlock);
                joinResult.open();
                if (joinResult.hasNext()) {
                    preLeftBlock = leftBlock;
                    return joinResult.next();
                }
            }
        }
        return null;
    }

    @Override
    public DbIterator[] getChildren() {
        return children;
    }

    @Override
    public void setChildren(DbIterator[] children) {
        this.children = children;
    }

    private TupleIterator mergeJoin(ArrayList<Tuple> leftBlock, ArrayList<Tuple> rightBlock) throws DbException {
        int i = 0;
        int j = 0;
        ArrayList<Tuple> result = new ArrayList<Tuple>();
        switch (this.p.getOperator()) {
            case EQUALS:
                JoinPredicate ltPredicate = new JoinPredicate(this.p.getField1(), Predicate.Op.LESS_THAN, this.p.getField2());
                while (i < leftBlock.size() && j < rightBlock.size()) {
                    Tuple left = leftBlock.get(i);
                    Tuple right = rightBlock.get(j);
                    if (this.p.filter(left, right)) {
                        int begin1 = i;
                        int begin2 = j;
                        while (i < leftBlock.size() && this.p.filter(leftBlock.get(i), right)) {
                            i += 1;
                        }
                        while (j < rightBlock.size() && this.p.filter(left, rightBlock.get(j))) {
                            j += 1;
                        }
                        int end1 = i;
                        int end2 = j;
                        for (int p = begin1; p < end1; p++) {
                            for (int q = begin2; q < end2; q++) {
                                Tuple t = mergeTuples(leftBlock.get(p), rightBlock.get(q));
                                result.add(t);
                            }
                        }
                    } else if (ltPredicate.filter(left, right)) {
                        i += 1;
                    } else {
                        j += 1;
                    }
                }
                break;
            case LESS_THAN:
            case LESS_THAN_OR_EQ:
                while (i < leftBlock.size()) {
                    Tuple left = leftBlock.get(i);
                    j = rightBlock.size() - 1;
                    while (j >= 0) {
                        Tuple right = rightBlock.get(j);
                        j -= 1;
                        if (this.p.filter(left, right)) {
                            Tuple t = mergeTuples(left, right);
                            result.add(t);
                        } else {
                            break;
                        }
                    }
                    i += 1;
                }
                break;
            case GREATER_THAN:
            case GREATER_THAN_OR_EQ:
                while (i < leftBlock.size()) {
                    Tuple left = leftBlock.get(i);
                    j = 0;
                    while (j < rightBlock.size()) {
                        Tuple right = rightBlock.get(j);
                        j += 1;
                        if (this.p.filter(left, right)) {
                            Tuple t = mergeTuples(left, right);
                            result.add(t);
                        } else {
                            break;
                        }
                    }
                    i += 1;
                }
                break;
            default:
                throw new DbException("JoinPredicate is Illegal");
        }
        return new TupleIterator(this.td, result);
    }

    private Tuple mergeTuples(Tuple left, Tuple right) {
        Tuple t = new Tuple(this.td);
        int k = 0;
        for (int i = 0; i < left.getTupleDesc().numFields(); i++) {
            t.setField(k, left.getField(i));
            k++;
        }
        for (int i = 0; i < right.getTupleDesc().numFields(); i++) {
            t.setField(k, right.getField(i));
            k++;
        }
        return t;
    }

    private ArrayList<Tuple> getNextSortedBlock(DbIterator child, int size, int field) throws DbException, TransactionAbortedException, NoSuchElementException {
        ArrayList<Tuple> block = getNextBlock(child, size);
        sortBlock(block, field);
        return block;
    }

    private ArrayList<Tuple> getNextBlock(DbIterator child, int size) throws DbException, TransactionAbortedException, NoSuchElementException {
        ArrayList<Tuple> block = new ArrayList<Tuple>();
        while (child.hasNext()) {
            block.add(child.next());
            if (block.size() == size) {
                break;
            }
        }
        return block;
    }

    private void sortBlock(ArrayList<Tuple> block, int field) {
        final int f = field;
        Collections.sort(block, new Comparator<Tuple>() {
            @Override
            public int compare(Tuple lhs, Tuple rhs) {
                Field lf = lhs.getField(f);
                Field rf = rhs.getField(f);
                if (lf.compare(Predicate.Op.LESS_THAN, rf)) {
                    return -1;
                } else if (lf.compare(Predicate.Op.EQUALS, rf)) {
                    return 0;
                } else {
                    return 1;
                }
            }
        });
    }
}
